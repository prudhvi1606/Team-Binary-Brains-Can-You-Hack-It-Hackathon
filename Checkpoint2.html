<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Space Ship Game</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif;}
  canvas { display: block; margin: 0 auto; position: absolute; top: 0; left: 0; }
  #gameOverDialog, #doubleGunPopup {
    display: none; position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.85); color: white; padding: 20px 30px; text-align: center;
    border-radius: 10px; z-index: 10; box-shadow: 0 0 15px white;
  }
  #gameOverDialog h2 { margin: 0 0 15px 0; font-size: 32px; }
  #restartBtn {
    padding: 12px 25px; font-size: 18px; cursor: pointer;
    border: none; border-radius: 5px; background-color: #00bcd4; color: #000;
    transition: background-color 0.3s ease;
  }
  #restartBtn:hover { background-color: #0097a7; }
</style>
</head>
<body>
<canvas id="bgCanvas"></canvas>
<canvas id="gameCanvas" width="1300" height="700"></canvas>
<div id="gameOverDialog">
  <h2 id="gameOverTitle">Game Over</h2>
  <p id="finalScore"></p>
  <button id="restartBtn">Restart</button>
</div>
<div id="doubleGunPopup">
   Double Gun Mode Activated!</div>
<script>
/* ---------------- BACKGROUND ---------------- */
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');
bgCanvas.width = window.innerWidth;
bgCanvas.height = window.innerHeight;
class Particle {
  constructor(effect){
    this.effect = effect;
    this.radius = Math.floor(Math.random() * 3 + 1);
    this.x = Math.random() * this.effect.width;
    this.y = Math.random() * this.effect.height;
    this.vx = Math.random() * 1 - 0.5;
    this.vy = Math.random() * 1 - 0.5;
  }
  draw(context){
    context.beginPath();
    context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    context.fillStyle = "white";
    context.fill();
  }
  update(){
    this.x += this.vx;
    this.y += this.vy;
    if (this.x < 0 || this.x > this.effect.width) this.vx *= -1;
    if (this.y < 0 || this.y > this.effect.height) this.vy *= -1;
  }
}
class Effect {
  constructor(canvas, context){
    this.canvas = canvas;
    this.context = context;
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.particles = [];
    this.numberOfParticles = 100;
    this.createParticles();
  }
  createParticles(){
    for (let i = 0; i < this.numberOfParticles; i++){
      this.particles.push(new Particle(this));
    }
  }
  handleParticles(context){
    this.particles.forEach(particle => {
      particle.draw(context);
      particle.update();
    });
  }
}
const effect = new Effect(bgCanvas, bgCtx);
function animateBackground(){
  bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
  effect.handleParticles(bgCtx);
  requestAnimationFrame(animateBackground);
}
animateBackground();
/* ---------------- FLOATING TEXT ---------------- */
class FloatingText {
  constructor(text, x, y, color="yellow") {
    this.text = text;
    this.x = x;
    this.y = y;
    this.color = color;
    this.alpha = 1;
    this.lifetime = 1000;
    this.startTime = Date.now();
  }
  draw(ctx) {
    ctx.fillStyle = `rgba(${this.color === "red" ? "255,0,0" : this.color === "lime" ? "0,255,0" : "255,255,0"},${this.alpha})`;
    ctx.font = '20px Arial';
    ctx.fillText(this.text, this.x, this.y);
  }
  update() {
    const elapsed = Date.now() - this.startTime;
    if (elapsed > this.lifetime) return false;
    this.y -= 0.5;
    this.alpha = 1 - elapsed / this.lifetime;
    return true;
  }
}
/* ---------------- PLAYER & OBJECTS ---------------- */
class Player {
  constructor(game) {
    this.game = game;
    this.x = this.game.width * 0.35;
    this.y = game.height / 2 - 20;
    this.width = 40;
    this.height = 40;
    this.health = 5;
    this.ammo = 50;
    this.maxAmmo = 50;
    this.ammoTimer = 0;
    this.ammoRechargeInterval = 400;
    this.projectiles = [];
    this.shootCooldown = 0;
    this.shootCooldownMax = 200;
  }
  update(deltaTime) {
    if (this.ammo < this.maxAmmo) {
      this.ammoTimer += deltaTime;
      if (this.ammoTimer > this.ammoRechargeInterval) {
        this.ammo++;
        this.ammoTimer = 0;
      }
    }
    if (this.shootCooldown > 0) this.shootCooldown -= deltaTime;
    this.projectiles.forEach(p => p.update());
    this.projectiles = this.projectiles.filter(p => !p.markedForDeletion);
  }
  draw(ctx) {
    ctx.fillStyle = 'cyan';
    ctx.fillRect(this.x, this.y, this.width, this.height);
    this.projectiles.forEach(p => p.draw(ctx));
  }
  shoot() {
    if (this.ammo > 0 && this.shootCooldown <= 0) {
      // Shooting audio per shot (glitch-free)
      const audio = new Audio('shootfin.mp3');
      audio.volume = 0.5;
      audio.play();
      if (this.game.doubleGunActive) {
        this.projectiles.push(new Projectile(this.game, this.x + this.width, this.y + 5));
        this.projectiles.push(new Projectile(this.game, this.x + this.width, this.y + this.height - 8));
      } else {
        this.projectiles.push(new Projectile(this.game, this.x + this.width, this.y + this.height / 2));
      }
      this.ammo--;
      this.game.shotsFired++;
      this.shootCooldown = this.shootCooldownMax;
    }
  }
}
class Projectile {
  constructor(game, x, y) {
    this.game = game;
    this.x = x;
    this.y = y;
    this.width = 10;
    this.height = 3;
    this.speed = 7;
    this.markedForDeletion = false;
  }
  update() {
    this.x += this.speed;
    if (this.x > this.game.width) this.markedForDeletion = true;
  }
  draw(ctx) {
    ctx.fillStyle = 'yellow';
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}
class Asteroid {
  constructor(game) {
    this.game = game;
    const asteroidTypes = [
      { type: 'small', sizeMin: 20, sizeMax: 40, speedMin: 1, speedMax: 2, points: 5, rarity: 0.6 },
      { type: 'medium', sizeMin: 40, sizeMax: 70, speedMin: 0.8, speedMax: 1.5, points: 15, rarity: 0.3 },
      { type: 'large', sizeMin: 70, sizeMax: 100, speedMin: 0.5, speedMax: 1.2, points: 30, rarity: 0.1 }
    ];
    let rand = Math.random();
    let chosenType = asteroidTypes[0];
    let cumulative = 0;
    for (let t of asteroidTypes) {
      cumulative += t.rarity;
      if (rand <= cumulative) {
        chosenType = t;
        break;
      }
    }
    this.type = chosenType.type;
    this.size = Math.random() * (chosenType.sizeMax - chosenType.sizeMin) + chosenType.sizeMin;
    this.x = this.game.width;
    this.y = Math.random() * (this.game.height - this.size);
    this.speed = Math.random() * (chosenType.speedMax - chosenType.speedMin) + chosenType.speedMin;
    this.health = Math.ceil(this.size / 15);
    this.points = chosenType.points;
    this.markedForDeletion = false;
  }
  update() {
    this.x -= this.speed;
    if (this.x + this.size < 0) this.markedForDeletion = true;
  }
  draw(ctx) {
    ctx.fillStyle = this.type === 'large' ? 'darkred' : this.type === 'medium' ? 'darkgray' : 'gray';
    ctx.beginPath();
    ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size/2, 0, Math.PI * 2);
    ctx.fill();
  }
}
class FuelPack {
  constructor(game) {
    this.game = game;
    this.size = 20;
    this.x = this.game.width;
    this.y = Math.random() * (this.game.height - this.size);
    this.speed = 2;
    this.markedForDeletion = false;
  }
  update() {
    this.x -= this.speed;
    if (this.x + this.size < 0) this.markedForDeletion = true;
  }
  draw(ctx) {
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.moveTo(this.x + this.size/2, this.y);
    ctx.lineTo(this.x + this.size, this.y + this.size/2);
    ctx.lineTo(this.x + this.size/2, this.y + this.size);
    ctx.lineTo(this.x, this.y + this.size/2);
    ctx.closePath();
    ctx.fill();
  }
}
/* ---------------- GAME ---------------- */
class Game {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.player = new Player(this);
    this.asteroids = [];
    this.fuelPacks = [];
    this.asteroidTimer = 0;
    this.asteroidInterval = 1500;
    this.fuelPackTimer = 0;
    this.fuelPackInterval = 6000;
    this.score = 0;
    this.shotsFired = 0;
    this.successfulHits = 0;
    this.gameOver = false;
    this.win = false;
    this.time = 0;
    this.maxTime = 120000;
    this.doubleGunActive = false;
    this.doubleGunTimer = 0;
    this.doubleGunCooldown = 0;
    this.floatingTexts = [];
    this.fuel = 100;
    this.fuelDrain = 0.08;
    this.gameOverAudioPlayed = false;
    this.winAudioPlayed = false;
  }
  update(deltaTime) {
    if (this.gameOver) return;

    this.time += deltaTime;
    this.fuel -= this.fuelDrain;

    if (this.fuel <= 0 && !this.gameOver) {
      this.fuel = 0;
      this.triggerGameOver();
    }

    if (this.time > this.maxTime && !this.gameOver) {
      if (this.player.health > 0 && this.fuel > 0) {
        this.triggerWin();
      } else if (!this.gameOver) {
        this.triggerGameOver();
      }
    }

    this.player.update(deltaTime);
    this.asteroidTimer += deltaTime;
    if (this.asteroidTimer > this.asteroidInterval) {
      this.asteroids.push(new Asteroid(this));
      this.asteroidTimer = 0;
    }
    this.asteroids.forEach(a => a.update());
    this.asteroids = this.asteroids.filter(a => !a.markedForDeletion);

    this.fuelPackTimer += deltaTime;
    if (this.fuelPackTimer > this.fuelPackInterval) {
      this.fuelPacks.push(new FuelPack(this));
      this.fuelPackTimer = 0;
    }
    this.fuelPacks.forEach(f => f.update());
    this.fuelPacks = this.fuelPacks.filter(f => !f.markedForDeletion);

    this.floatingTexts = this.floatingTexts.filter(ft => ft.update());

    if (this.doubleGunActive) {
      this.doubleGunTimer -= deltaTime;
      if (this.doubleGunTimer <= 0) {
        this.doubleGunActive = false;
        document.getElementById('doubleGunPopup').textContent = "Double Gun Mode Ended!";
        document.getElementById('doubleGunPopup').style.display = 'block';
        setTimeout(()=>document.getElementById('doubleGunPopup').style.display="none",2000);
      }
    }
    if (this.doubleGunCooldown > 0) this.doubleGunCooldown -= deltaTime;

    this.checkCollisions();
  }
  triggerGameOver() {
    this.gameOver = true;
    if (!this.gameOverAudioPlayed) {
      const goAudio = new Audio('game0ver1.mp3');
      goAudio.volume = 0.8;
      goAudio.play();
      this.gameOverAudioPlayed = true;
    }
  }
  triggerWin() {
    this.win = true;
    this.gameOver = true;
    if (!this.winAudioPlayed) {
      const winAudio = new Audio('win_1.mp3');
      winAudio.volume = 0.8;
      winAudio.play();
      this.winAudioPlayed = true;
    }
  }
  draw(ctx) {
    this.player.draw(ctx);
    this.asteroids.forEach(a => a.draw(ctx));
    this.fuelPacks.forEach(f => f.draw(ctx));
    this.floatingTexts.forEach(ft => ft.draw(ctx));
    this.drawUI(ctx);
  }
  drawUI(ctx) {
    const paddingRight = 20;
    const lineHeight = 30;
    ctx.fillStyle = 'white';
    ctx.font = '18px Arial';
    const xPos = this.width - paddingRight;
    ctx.textAlign = 'right';

    let hearts = "❤️".repeat(this.player.health);
    ctx.fillText(`Health: ${hearts}`, xPos, 30);
    ctx.fillText(`Ammo: ${this.player.ammo}`, xPos, 30 + lineHeight);
    ctx.fillText(`Score: ${this.score}`, xPos, 30 + lineHeight * 2);
    let accuracy = this.shotsFired ? ((this.successfulHits / this.shotsFired * 100).toFixed(1)) : 0;
    ctx.fillText(`Accuracy: ${accuracy}%`, xPos, 30 + lineHeight * 3);
    ctx.fillText(`Time: ${Math.max(0, Math.floor((this.maxTime - this.time) / 1000))}`, xPos, 30 + lineHeight * 4);

    let barWidth = 200;
    let barHeight = 20;
    let barX = this.width - barWidth - paddingRight;
    let barY = 30 + lineHeight * 5;
    ctx.fillStyle = "red";
    ctx.fillRect(barX, barY, this.fuel / 100 * barWidth, barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(barX, barY, barWidth, barHeight);
    ctx.fillStyle = "white";
    ctx.fillText("Fuel", xPos, barY + barHeight + 20);
  }
  checkCollisions() {
    this.player.projectiles.forEach(projectile => {
      this.asteroids.forEach(asteroid => {
        if (
          projectile.x < asteroid.x + asteroid.size &&
          projectile.x + projectile.width > asteroid.x &&
          projectile.y < asteroid.y + asteroid.size &&
          projectile.y + projectile.height > asteroid.y
        ) {
          asteroid.health--;
          projectile.markedForDeletion = true;
          if (asteroid.health <= 0) {
            asteroid.markedForDeletion = true;
            this.score += asteroid.points;
            this.successfulHits++;
            this.floatingTexts.push(new FloatingText("+"+asteroid.points, asteroid.x, asteroid.y, "yellow"));
          }
        }
      });
    });

    this.asteroids.forEach(asteroid => {
      if (
        this.player.x < asteroid.x + asteroid.size &&
        this.player.x + this.player.width > asteroid.x &&
        this.player.y < asteroid.y + asteroid.size &&
        this.player.y + this.player.height > asteroid.y
      ) {
        asteroid.markedForDeletion = true;
        let damage = asteroid.size < 50 ? 1 : 2;
        this.player.health -= damage;
        this.floatingTexts.push(new FloatingText("-"+damage, this.player.x+20, this.player.y, "red"));
        if (this.player.health <= 0 && !this.gameOver) {
          this.triggerGameOver();
        }
      }
    });

    this.fuelPacks.forEach(fuelPack => {
      if (
        this.player.x < fuelPack.x + fuelPack.size &&
        this.player.x + this.player.width > fuelPack.x &&
        this.player.y < fuelPack.y + fuelPack.size &&
        this.player.y + this.player.height > fuelPack.y
      ) {
        fuelPack.markedForDeletion = true;
        this.fuel = Math.min(100, this.fuel + 30);
        this.floatingTexts.push(new FloatingText("+Fuel", this.player.x+20, this.player.y, "lime"));
      }
    });
  }
}
/* ---------------- MAIN LOOP ---------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let game;
let lastTime = 0;
let isMouseDown = false;
let animId;
function startGame() {
  game = new Game(canvas.width, canvas.height);
  lastTime = 0;
  isMouseDown = false;
  cancelAnimationFrame(animId);
  animate();
}
function animate(timeStamp = 0) {
  const deltaTime = timeStamp - lastTime;
  lastTime = timeStamp;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (isMouseDown) game.player.shoot();
  game.update(deltaTime);
  game.draw(ctx);

  if (!game.gameOver) {
    animId = requestAnimationFrame(animate);
  } else {
    let accuracy = game.shotsFired ? ((game.successfulHits / game.shotsFired) * 100).toFixed(1) : 0;
    finalScoreText.textContent = `Your Score: ${game.score} | Accuracy: ${accuracy}%`;
    if (game.win) {
      document.getElementById('gameOverTitle').textContent = "🎉 You Win!";
    } else {
      document.getElementById('gameOverTitle').textContent = "Game Over";
    }
    gameOverDialog.style.display = 'block';
  }
}
startGame();
/* ---------------- CONTROLS ---------------- */
const gameOverDialog = document.getElementById('gameOverDialog');
const finalScoreText = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');
const doubleGunPopup = document.getElementById('doubleGunPopup');
restartBtn.addEventListener('click', () => {
  gameOverDialog.style.display = 'none';
  startGame();
});
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const mouseY = e.clientY - rect.top;
  game.player.y = Math.min(Math.max(mouseY - game.player.height / 2, 0), game.height - game.player.height);
});
canvas.addEventListener('mousedown', () => { isMouseDown = true; });
canvas.addEventListener('mouseup', () => { isMouseDown = false; });
canvas.addEventListener('dblclick', () => {
  if (game.doubleGunCooldown <= 0 && !game.doubleGunActive) {
    game.doubleGunActive = true;
    game.doubleGunTimer = 7000;
    game.doubleGunCooldown = 12000;
    doubleGunPopup.textContent = " Double Gun Mode Activated!";
    doubleGunPopup.style.display = 'block';
    setTimeout(()=>doubleGunPopup.style.display="none",2000);
  }
});
</script>
</body>
</html>
