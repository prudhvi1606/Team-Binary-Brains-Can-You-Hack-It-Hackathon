<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Combined Space Miner & Ship Game — Fixed Restart</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
  canvas { display: block; margin: 0 auto; position: absolute; top: 0; left: 0; }
  #gameOverDialog, #doubleGunPopup {
    display: none;
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.85);
    color: white;
    padding: 20px 30px;
    text-align: center;
    border-radius: 10px;
    z-index: 10;
    box-shadow: 0 0 15px white;
  }
  #gameOverDialog h2 { margin: 0 0 15px 0; font-size: 32px; }
  #restartBtn {
    padding: 12px 25px; font-size: 18px; cursor: pointer;
    border: none; border-radius: 5px;
    background-color: #00bcd4; color: #000;
    transition: background-color 0.3s ease;
  }
  #restartBtn:hover { background-color: #0097a7; }
</style>
</head>
<body>
<canvas id="bgCanvas"></canvas>
<canvas id="gameCanvas" width="1500" height="700"></canvas>

<div id="gameOverDialog">
  <h2 id="gameOverTitle">Game Over</h2>
  <p id="finalScore"></p>
  <button id="restartBtn">Restart</button>
</div>
<div id="doubleGunPopup">Double Gun Mode Activated!</div>

<script>
/* ----------------------------- DOM references ---------------------------- */
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const gameOverDialog = document.getElementById('gameOverDialog');
const finalScoreText = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');
const doubleGunPopup = document.getElementById('doubleGunPopup');

/* ---------------------------- Background starfield ---------------------- */
function resizeBgCanvas() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
}
resizeBgCanvas();

class StarParticle {
  constructor(effect){
    this.effect = effect;
    this.radiusBase = 1.3 + Math.random() * 2.0;
    this.radius = this.radiusBase;
    this.x = Math.random() * this.effect.width;
    this.y = Math.random() * this.effect.height;
    this.twinklePhase = Math.random() * Math.PI * 2;
    this.twinkleSpeed = 0.63 + Math.random() * 0.74;
    this.opacityBase = 0.50 + Math.random() * 0.25;
    this.opacity = this.opacityBase;
    this.speedX = 0.80 + Math.random() * 0.42;
  }
  draw(ctx, t){
    this.radius = this.radiusBase + Math.sin(this.twinklePhase + t * this.twinkleSpeed) * 0.46;
    this.opacity = this.opacityBase + Math.sin(this.twinklePhase + t * this.twinkleSpeed) * 0.18;
    ctx.save();
    ctx.globalAlpha = Math.max(0.1, Math.min(1, this.opacity));
    ctx.beginPath();
    ctx.arc(this.x, this.y, Math.max(1, this.radius), 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.shadowColor = "#fff";
    ctx.shadowBlur = 11 + (this.radius * 2.2);
    ctx.fill();
    ctx.restore();
  }
  update(dt){
    this.x -= this.speedX * dt * 0.025;
    if (this.x < -this.radius) this.x = this.effect.width + this.radius;
    if (this.y < 0) this.y = this.effect.height;
    if (this.y > this.effect.height) this.y = 0;
  }
}

class StarNetworkEffect {
  constructor(canvas, context){
    this.canvas = canvas;
    this.context = context;
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.particles = [];
    this.numberOfParticles = Math.max(Math.floor((this.width * this.height) / 1300), 70);
    this.maxLinkDist = Math.max(this.width, this.height) / 10.8;
    this.createParticles();
    window.addEventListener('resize', () => this.resize(window.innerWidth, window.innerHeight));
  }
  createParticles(){
    this.particles = [];
    for (let i = 0; i < this.numberOfParticles; i++){
      this.particles.push(new StarParticle(this));
    }
  }
  connectStars(ctx){
    for (let a = 0; a < this.particles.length; a++){
      for (let b = a+1; b < this.particles.length; b++){
        const dx = this.particles[a].x - this.particles[b].x;
        const dy = this.particles[a].y - this.particles[b].y;
        const distsq = dx*dx + dy*dy;
        const maxDistSq = this.maxLinkDist*this.maxLinkDist;
        if (distsq < maxDistSq){
          const dist = Math.sqrt(distsq);
          const fade = 0.37 - dist / this.maxLinkDist;
          if(fade>0){
            ctx.save();
            ctx.globalAlpha = Math.max(0, fade*0.76);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 0.8 + 0.5*(this.particles[a].radius+this.particles[b].radius)*0.47;
            ctx.beginPath();
            ctx.moveTo(this.particles[a].x, this.particles[a].y);
            ctx.lineTo(this.particles[b].x, this.particles[b].y);
            ctx.stroke();
            ctx.restore();
          }
        }
      }
    }
  }
  handleParticles(ctx, now, dt){
    this.connectStars(ctx);
    this.particles.forEach(particle => {
      particle.draw(ctx, now);
      particle.update(dt);
    });
  }
  resize(width, height){
    this.canvas.width = width;
    this.canvas.height = height;
    this.width = width;
    this.height = height;
    this.numberOfParticles = Math.max(Math.floor((width * height) / 1300), 70);
    this.maxLinkDist = Math.max(width, height) / 10.8;
    this.createParticles();
  }
}
const starNet = new StarNetworkEffect(bgCanvas, bgCtx);
let lastBgTime = performance.now();
function animateBackground(){
  bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
  const now = performance.now() * 0.002;
  const cur = performance.now();
  const dt = Math.max(7, cur - lastBgTime);
  lastBgTime = cur;
  starNet.handleParticles(bgCtx, now, dt);
  requestAnimationFrame(animateBackground);
}
animateBackground();

/* ------------------------------- Images -------------------------------- */
const asteroidImgs = [
  (() => { const img = new Image(); img.src = "asteroid1.jpg"; return img; })(),
  (() => { const img = new Image(); img.src = "asteroid3.jpg"; return img; })()
];
const playerShipImg = new Image();
playerShipImg.src = "spaceship.jpg";

/* -------------------------------- Sounds -------------------------------- */
const shootAudio = new Audio('shootfin.mp3'); shootAudio.volume = 0.5;
const gameOverAudio = new Audio('game0ver1.mp3'); gameOverAudio.volume = 0.8;
const winAudio = new Audio('win_1.mp3'); winAudio.volume = 0.8;

/* ------------------------------ Game classes ---------------------------- */
class FloatingText {
  constructor(text, x, y, color="yellow") {
    this.text = text; this.x = x; this.y = y; this.color = color;
    this.alpha = 1; this.lifetime = 1000; this.startTime = Date.now();
  }
  draw(ctx) {
    ctx.fillStyle = `rgba(${this.color === "red" ? "255,0,0" : this.color === "lime" ? "0,255,0" : "255,255,0"},${this.alpha})`;
    ctx.font = '20px Arial';
    ctx.fillText(this.text, this.x, this.y);
  }
  update() {
    const elapsed = Date.now() - this.startTime;
    if (elapsed > this.lifetime) return false;
    this.y -= 0.5;
    this.alpha = 1 - elapsed / this.lifetime;
    return true;
  }
}

class Player {
  constructor(game) {
    this.game = game;
    this.x = 30;
    this.y = game.height / 2 - 20;
    this.displayY = this.y;
    this.targetY = this.y;
    this.velocityY = 0;
    this.spring = 0.18;
    this.damping = 0.66;
    this.health = 5;
    this.ammo = 50; this.maxAmmo = 50; this.ammoTimer = 0; this.ammoRechargeInterval = 400;
    this.projectiles = [];
    this.shootCooldown = 0; this.shootCooldownMax = 200;
    this.time = 0;
    this.shipWidth = 120; this.shipHeight = 72;
  }
  update(deltaTime) {
    this.time += deltaTime;
    let force = (this.targetY - this.displayY) * this.spring;
    this.velocityY += force;
    this.velocityY *= this.damping;
    this.displayY += this.velocityY;
    if(this.displayY < 0) { this.displayY = 0; this.velocityY = 0; }
    if(this.displayY > this.game.height - this.shipWidth) { this.displayY = this.game.height - this.shipWidth; this.velocityY = 0; }
    if (this.ammo < this.maxAmmo) {
      this.ammoTimer += deltaTime;
      if (this.ammoTimer > this.ammoRechargeInterval) { this.ammo++; this.ammoTimer = 0; }
    }
    if (this.shootCooldown > 0) this.shootCooldown -= deltaTime;
    this.projectiles.forEach(p => p.update());
    this.projectiles = this.projectiles.filter(p => !p.markedForDeletion);
  }
  draw(ctx) {
    const hoverAmplitude = 6; const hoverSpeed = 0.002;
    const hoverY = Math.sin(this.time * hoverSpeed) * hoverAmplitude;
    if (playerShipImg.complete && playerShipImg.naturalWidth) {
      // draw image with a safe rotation placement
      const drawW = this.shipWidth;
      const aspect = playerShipImg.width / playerShipImg.height || 1;
      const drawH = drawW / aspect;
      const posX = this.x + drawW/2;
      const posY = this.displayY + hoverY + drawH/2;
      ctx.save();
      ctx.translate(posX, posY);
      ctx.rotate(-Math.PI/2);
      ctx.drawImage(playerShipImg, -drawW/2, -drawH/2, drawW, drawH);
      ctx.restore();
    } else {
      ctx.save();
      ctx.translate(this.x + this.shipHeight / 2, this.displayY + hoverY + this.shipWidth / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillStyle = "cyan";
      ctx.fillRect(-this.shipWidth / 2, -this.shipHeight / 2, this.shipWidth, this.shipHeight);
      ctx.restore();
    }
    this.projectiles.forEach(p => p.draw(ctx));
  }
  shoot() {
    const hoverAmplitude = 6; const hoverSpeed = 0.002;
    const hoverY = Math.sin(this.time * hoverSpeed) * hoverAmplitude;
    if (this.ammo > 0 && this.shootCooldown <= 0) {
      try { shootAudio.currentTime = 0; shootAudio.play(); } catch(e){}
      let gunX = this.x + this.shipWidth;
      let gunY = this.displayY + hoverY + this.shipWidth/2 - 4;
      if (this.game.doubleGunActive) {
        this.projectiles.push(new Projectile(this.game, gunX, this.displayY + hoverY + 28));
        this.projectiles.push(new Projectile(this.game, gunX, this.displayY + hoverY + this.shipWidth - 44));
      } else {
        this.projectiles.push(new Projectile(this.game, gunX, gunY));
      }
      this.ammo--;
      this.game.shotsFired++;
      this.shootCooldown = this.shootCooldownMax;
    }
  }
}

class Projectile {
  constructor(game, x, y) { this.game = game; this.x = x; this.y = y; this.width = 54; this.height = 9; this.speed = 20; this.markedForDeletion = false; }
  update() { this.x += this.speed; if (this.x > this.game.width) this.markedForDeletion = true; }
  draw(ctx) { ctx.save(); ctx.fillStyle = "#2196f3"; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.restore(); }
}

class FuelPack {
  constructor(game) {
    this.game = game; this.size = 28; this.x = this.game.width + this.size; this.y = Math.random() * (this.game.height - this.size);
    this.speed = 2.5+ Math.random()*2; this.markedForDeletion = false;
  }
  update() { this.x -= this.speed; if (this.x + this.size < 0) this.markedForDeletion = true; }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x + this.size/2, this.y + this.size/2);
    ctx.rotate(Math.PI/4);
    ctx.beginPath();
    ctx.moveTo(0, -this.size/2);
    for (let i = 1; i < 4; i++) {
      ctx.lineTo((this.size/2)*Math.cos(i*Math.PI/2 - Math.PI/2),
                 (this.size/2)*Math.sin(i*Math.PI/2 - Math.PI/2));
    }
    ctx.closePath();
    ctx.fillStyle = 'lime';
    ctx.globalAlpha = 0.84;
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "white";
    ctx.globalAlpha = 1.0;
    ctx.stroke();
    ctx.restore();
  }
}

class Asteroid {
  constructor(game) {
    this.game = game;
    this.size = Math.random() * 40 + 40;
    this.x = this.game.width + this.size/2;
    this.y = Math.random() * (this.game.height - this.size);
    this.speed = Math.random() * 4 + 2;
    this.health = Math.ceil(this.size / 15);
    this.markedForDeletion = false;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotationSpeed = (Math.random()-0.5) * 0.022;
    this.fireT = Math.random() * 99999;
    this.imgIdx = Math.floor(Math.random() * asteroidImgs.length);
  }
  update() { this.x -= this.speed; this.rotation += this.rotationSpeed; this.fireT += 0.23; if (this.x + this.size < 0) this.markedForDeletion = true; }
  draw(ctx) {
    const centerX = this.x + this.size / 2;
    const centerY = this.y + this.size / 2;
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(this.rotation);
    for(let i=0;i<6;++i){
      const ang = ((Math.PI*2)/6)*i;
      const len = this.size*0.47 + Math.sin(this.fireT*0.15 + i)*8;
      ctx.save();
      ctx.rotate(ang);
      let grad = ctx.createRadialGradient(0, -this.size/2.1, 4, 0, -this.size/2.1, len);
      grad.addColorStop(0, `rgba(255,255,0,0.85)`);
      grad.addColorStop(0.55, `rgba(255,146,0,0.86)`);
      grad.addColorStop(0.8, `rgba(255,64,0,0.46)`);
      grad.addColorStop(1, `rgba(255,64,0,0)`);
      ctx.beginPath();
      ctx.arc(0, len, 16, 0, Math.PI*2);
      ctx.fillStyle = grad;
      ctx.globalAlpha = 0.8 + Math.sin(this.fireT*0.09 + i)*0.12;
      ctx.fill();
      ctx.restore();
    }
    ctx.globalAlpha = 1;
    let asteroidImage = asteroidImgs[this.imgIdx];
    if (asteroidImage.complete && asteroidImage.naturalWidth) {
      const iw = asteroidImage.width, ih = asteroidImage.height, box = this.size;
      let scale = Math.min(box/iw, box/ih);
      let w = iw * scale, h = ih * scale;
      ctx.drawImage(asteroidImage, -w/2, -h/2, w, h);
    } else {
      ctx.beginPath();
      ctx.arc(0,0, this.size/2, 0, Math.PI*2);
      ctx.fillStyle = "gray";
      ctx.fill();
    }
    ctx.restore();
  }
}

class Game {
  constructor(width, height) {
    this.width = width; this.height = height;
    this.player = new Player(this);
    this.asteroids = []; this.fuelPacks = [];
    this.asteroidTimer = 0; this.asteroidInterval = 2800;
    this.fuelPackTimer = 0; this.fuelPackInterval = 8300;
    this.score = 0; this.shotsFired = 0; this.successfulHits = 0;
    this.fuel = 100; this.maxFuel = 100; this.fuelDecreasePerSecond = 4;
    this.gameOver = false; this.win = false; this.time = 0; this.maxTime = 60000;
    this.doubleGunActive = false; this.doubleGunTimer = 0; this.doubleGunCooldown = 0;
    this.floatingTexts = []; this.gameOverAudioPlayed = false; this.winAudioPlayed = false;
  }
  update(deltaTime) {
    if (this.gameOver) return;
    this.time += deltaTime;
    this.fuel -= this.fuelDecreasePerSecond * (deltaTime / 1000);
    if (this.fuel < 0) this.fuel = 0;
    if (this.fuel === 0) { this.triggerGameOver(); }
    if (this.time >= this.maxTime && !this.gameOver) {
      if (this.player.health > 0 && this.fuel > 0) { this.triggerWin(); }
      else if (!this.gameOver) { this.triggerGameOver(); }
    }
    this.player.update(deltaTime);
    this.asteroidTimer += deltaTime;
    if (this.asteroidTimer > this.asteroidInterval) { this.asteroids.push(new Asteroid(this)); this.asteroidTimer = 0; }
    this.asteroids.forEach(a => a.update());
    this.asteroids = this.asteroids.filter(a => !a.markedForDeletion);
    this.fuelPackTimer += deltaTime;
    if (this.fuelPackTimer > this.fuelPackInterval) { this.fuelPacks.push(new FuelPack(this)); this.fuelPackTimer = 0; }
    this.fuelPacks.forEach(f => f.update());
    this.fuelPacks = this.fuelPacks.filter(f => !f.markedForDeletion);
    this.floatingTexts = this.floatingTexts.filter(ft => ft.update());
    if (this.doubleGunActive) {
      this.doubleGunTimer -= deltaTime;
      if (this.doubleGunTimer <= 0) {
        this.doubleGunActive = false;
        if (doubleGunPopup) {
          doubleGunPopup.textContent = "Double Gun Mode Ended!";
          doubleGunPopup.style.display = 'block';
          setTimeout(()=>doubleGunPopup.style.display="none", 2000);
        }
      }
    }
    if (this.doubleGunCooldown > 0) this.doubleGunCooldown -= deltaTime;
    this.checkCollisions();
  }
  triggerGameOver() {
    if (!this.gameOver) {
      this.gameOver = true;
      if (!this.gameOverAudioPlayed) {
        try { gameOverAudio.currentTime = 0; gameOverAudio.play(); } catch(e){}
        this.gameOverAudioPlayed = true;
      }
    }
  }
  triggerWin() {
    if (!this.win) {
      this.win = true; this.gameOver = true;
      if (!this.winAudioPlayed) {
        try { winAudio.currentTime = 0; winAudio.play(); } catch(e){}
        this.winAudioPlayed = true;
      }
    }
  }
  draw(ctx) {
    this.player.draw(ctx);
    this.asteroids.forEach(a => a.draw(ctx));
    this.fuelPacks.forEach(f => f.draw(ctx));
    this.floatingTexts.forEach(ft => ft.draw(ctx));
    this.drawUI(ctx);
  }
  drawUI(ctx) {
    ctx.save();
    ctx.textAlign = "right"; ctx.fillStyle = 'white'; ctx.font = '18px Arial';
    const lines = [
      `Health: ${"❤️".repeat(this.player.health)}`,
      `Ammo: ${this.player.ammo}`,
      `Score: ${this.score}`,
      `Accuracy: ${this.shotsFired ? ((this.successfulHits / this.shotsFired) * 100).toFixed(1) : "0"}%`,
      `Time: ${Math.floor((this.maxTime - this.time) / 1000)}`
    ];
    let startY = 40;
    lines.forEach((line, i) => ctx.fillText(line, this.width - 20, startY + (26 * i)));
    let barWidth = 180; let barHeight = 17;
    let barX = this.width - 30 - barWidth/2; let barY = startY + 26 * lines.length + 18;
    ctx.globalAlpha = 0.22; ctx.fillStyle = "#fff"; ctx.fillRect(barX, barY, barWidth, barHeight);
    ctx.globalAlpha = 1;
    let fuelRatio = Math.max(0, Math.min(1, this.fuel/this.maxFuel));
    ctx.fillStyle = "#ff4444"; ctx.fillRect(barX, barY, barWidth * fuelRatio, barHeight);
    ctx.lineWidth = 2; ctx.strokeStyle = "#fff"; ctx.strokeRect(barX, barY, barWidth, barHeight);
    ctx.fillStyle = "#fff"; ctx.font = "15px Arial"; ctx.textAlign = "center";
    ctx.fillText("Fuel", barX + barWidth/2, barY + barHeight + 18);
    ctx.restore();
  }
  checkCollisions() {
    this.player.projectiles.forEach(projectile => {
      this.asteroids.forEach(asteroid => {
        if (projectile.x < asteroid.x + asteroid.size &&
            projectile.x + projectile.width > asteroid.x &&
            projectile.y < asteroid.y + asteroid.size &&
            projectile.y + projectile.height > asteroid.y) {
          asteroid.health--;
          projectile.markedForDeletion = true;
          if (asteroid.health <= 0) {
            asteroid.markedForDeletion = true;
            let points = asteroid.size < 50 ? 5 : 10;
            this.score += points;
            this.successfulHits++;
            this.floatingTexts.push(new FloatingText("+"+points, asteroid.x, asteroid.y, "yellow"));
          }
        }
      });
    });

    this.asteroids.forEach(asteroid => {
      if (this.player.x < asteroid.x + asteroid.size &&
          this.player.x + this.player.shipWidth > asteroid.x &&
          this.player.displayY < asteroid.y + asteroid.size &&
          this.player.displayY + this.player.shipWidth > asteroid.y) {
        asteroid.markedForDeletion = true;
        let damage = asteroid.size < 50 ? 1 : 2;
        this.player.health -= damage;
        this.floatingTexts.push(new FloatingText("-"+damage, this.player.x+20, this.player.displayY, "red"));
        if (this.player.health <= 0) this.triggerGameOver();
      }
    });

    this.fuelPacks.forEach(fuelPack => {
      let pLeft = this.player.x, pRight = this.player.x + this.player.shipWidth;
      let pTop = this.player.displayY, pBottom = this.player.displayY + this.player.shipWidth;
      let fLeft = fuelPack.x, fRight = fuelPack.x + fuelPack.size;
      let fTop = fuelPack.y, fBottom = fuelPack.y + fuelPack.size;
      if (pLeft < fRight && pRight > fLeft && pTop < fBottom && pBottom > fTop) {
        fuelPack.markedForDeletion = true;
        let fuelAmount = 38;
        this.fuel = Math.min(this.fuel + fuelAmount, this.maxFuel);
        this.floatingTexts.push(new FloatingText("+Fuel", fuelPack.x, fuelPack.y-15, "lime"));
      }
    });
  }
}

/* ---------------------------- Main loop & control ---------------------- */
let game = null;
let lastTime = 0;
let isMouseDown = false;
let animId = null;

function startGame() {
  // stop any running animation first
  if (animId) { cancelAnimationFrame(animId); animId = null; }
  // stop audios
  try { shootAudio.pause(); shootAudio.currentTime = 0; } catch(e){}
  try { gameOverAudio.pause(); gameOverAudio.currentTime = 0; } catch(e){}
  try { winAudio.pause(); winAudio.currentTime = 0; } catch(e){}

  game = new Game(canvas.width, canvas.height);
  lastTime = performance.now(); // important: start from now to avoid giant delta
  isMouseDown = false;
  if (gameOverDialog) gameOverDialog.style.display = 'none';
  // start the animation loop
  animId = requestAnimationFrame(animate);
}

function animate(timeStamp) {
  if (!game) return; // guard
  // clamp deltaTime to reasonable value to avoid giant leaps after tab-switch or pause
  let deltaTime = timeStamp - lastTime;
  if (deltaTime > 1000) deltaTime = 16 * 4; // max cap (~64ms)
  lastTime = timeStamp;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (isMouseDown) game.player.shoot();
  game.update(deltaTime);
  game.draw(ctx);

  if (!game.gameOver) {
    animId = requestAnimationFrame(animate);
  } else {
    let accuracy = game.shotsFired ? ((game.successfulHits / game.shotsFired)*100).toFixed(1) : "0";
    if (finalScoreText) finalScoreText.textContent = `Your Score: ${game.score} | Accuracy: ${accuracy}%`;
    if (game.win) {
      if (document.getElementById('gameOverTitle')) document.getElementById('gameOverTitle').textContent = "🎉 You Win!";
    } else {
      if (document.getElementById('gameOverTitle')) document.getElementById('gameOverTitle').textContent = "Game Over";
    }
    if (gameOverDialog) gameOverDialog.style.display = 'block';
  }
}

/* ------------------------------- Controls ------------------------------- */
restartBtn.addEventListener('click', () => {
  // Cancel any running frame, reset and start fresh
  if (animId) cancelAnimationFrame(animId);
  animId = null;
  // ensure dialog hidden
  if (gameOverDialog) gameOverDialog.style.display = 'none';
  // reset game audio flags by recreating new Game instance on start
  startGame();
});

canvas.addEventListener('mousemove', e => {
  if (!game) return;
  const rect = canvas.getBoundingClientRect();
  const mouseY = e.clientY - rect.top;
  game.player.targetY = Math.min(Math.max(mouseY - game.player.shipWidth / 2, 0), game.height - game.player.shipWidth);
});
canvas.addEventListener('mousedown', () => { isMouseDown = true; });
canvas.addEventListener('mouseup', () => { isMouseDown = false; });

canvas.addEventListener('dblclick', () => {
  if (!game) return;
  if (game.doubleGunCooldown <= 0 && !game.doubleGunActive) {
    game.doubleGunActive = true;
    game.doubleGunTimer = 7000;
    game.doubleGunCooldown = 12000;
    if (doubleGunPopup) {
      doubleGunPopup.textContent = "Double Gun Mode Activated!";
      doubleGunPopup.style.display = 'block';
      setTimeout(() => doubleGunPopup.style.display = "none", 2000);
    }
  }
});

window.addEventListener('resize', () => {
  resizeBgCanvas();
  starNet.resize(window.innerWidth, window.innerHeight);
});

startGame();
</script>
</body>
</html>
